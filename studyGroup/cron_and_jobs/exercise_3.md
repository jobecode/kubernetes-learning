
## My solution


### Doc
https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
https://kubernetes.io/docs/concepts/workloads/controllers/job/


Create a Job named random-hash using the container image alpine:3.17.3 that executes the shell command echo $RANDOM | base64 | head -c 20. Configure the Job to execute with two Pods in parallel. The number of completions should be set to 5.
---------------------------------------------------------------------------------

We can use batch/v1 that finish after the job is done. The job is configured with completions: 5 and parallelism: 2, 
which means that Kubernetes will run up to 2 Pods in parallel until 5 executions are completed in total.
At certain point, there will be at most 2 Pods running, but in total 5 Pods will have been created over time (since each execution generates a new Pod).

Kubernetes jobs do not execue containers directly, but create pods that contain the containers.
To do this, we can create a template inside the job that contains the container.

First of all, we have to witch the context to the kind cluster

```bash
kubectl config get-contexts
```

```bash
kubectl config use-context kind-k8s-labs 
```


Then we can apply the manifest file:

```yaml

```bash
kubectl apply -f random-hash-job.yaml
```




Identify the Pods that executed the shell command. How many Pods do you expect to exist?
---------------------------------------------------------------------------------

```bash
kubectl get pods -n ckad
```


Alternatively, you can use the following command to list the Pods that belong to the Job:

```bash
k get pods --selector=job-name=random-hash -n ckad
```

We can filter by completed Pods using the following command:

```bash
k get pods --selector=job-name=random-hash -n ckad --field-selector=status.phase==Succeeded -n ckad
```


The output should look like this:

```bash
NAME                READY   STATUS      RESTARTS   AGE
random-hash-56g7m   0/1     Completed   0          2m4s
random-hash-gch6l   0/1     Completed   0          118s
random-hash-kwwl6   0/1     Completed   0          117s
random-hash-sdhrk   0/1     Completed   0          115s
random-hash-zrbvn   0/1     Completed   0          2m4s
```

There are 5 Pods that executed the shell command. All of them are in the Completed state.
As expected, Kubernetes has excuted 2 Pods in parallel until the completions value of 5 was reached.




Retrieve the generated hash from one of the Pods.
---------------------------------------------------------------------------------

To see the logs from a specific pod, we can get the hasg generated by the command:

```bash
kubectl logs random-hash-56g7m -n ckad
```



Delete the Job. Will the corresponding Pods continue to exist?
---------------------------------------------------------------------------------

```bash
kubectl delete job random-hash -n ckad
```

No, the pods have the policy restartPolicy: never, so the Pods will not continue to exist. When the Job is deleted, the Pods that belong to the Job are also deleted. 
Unless the job is configured with ttlSecondsAfterFinished, the pods will be deleted after the job is completed.



Create a new CronJob named google-ping. When executed, the Job should run a curl command for google.com. Pick an appropriate image. The execution should occur every two minutes.
---------------------------------------------------------------------------------

We could use the image curlimages/curl:latest which is a lightweight image that contains the curl command without the need to install it.
Alternatively, we could use the image alpine:3.17.3 and install curl using the command apk add --no-cache curl.

```yaml
containers:
  - name: google-ping
    image: alpine:latest
    command: ["/bin/sh", "-c", "apk add --no-cache curl && curl -I https://www.google.com"]
```



Watch the creation of the underlying Jobs managed by the CronJob. Check the command-line options of the relevant command or consult the Kubernetes documentation.
---------------------------------------------------------------------------------


```bash
kubectl get jobs -n ckad --watch
```

```
NAME                   STATUS     COMPLETIONS   DURATION   AGE
google-ping-29029972   Complete   1/1           4s         116s
google-ping-29029974   Running    0/1                      0s
google-ping-29029974   Running    0/1           0s         0s
google-ping-29029974   Running    0/1           4s         4s
google-ping-29029974   Complete   1/1           4s         4s
```

Reconfigure the CronJob to retain a history of seven executions.
---------------------------------------------------------------------------------

As the question doesn't specify whther success or failed executions we can configure it for both. 
We can add the following configuration to the spec of the CronJob. 


Note: if it is not configured the default value is 3 for both successfulJobsHistoryLimit and 1 for failedJobsHistoryLimit.
Note2: if we set it to 0, K8 will delete it immediately after the job is completed.
So in this case, K8s will keep a history of 7 successful and 7 failed before deleting the oldest ones. 

```yaml
spec:
  successfulJobsHistoryLimit: 7
  failedJobsHistoryLimit: 7
```


Reconfigure the CronJob to disallow a new execution if the current execution is still running. Consult the Kubernetes documentation for more information.
---------------------------------------------------------------------------------

To disallow concurrent executions, we can set the concurrencyPolicy field to Forbid under the spec of the CronJob.

```yaml
concurrencyPolicy: Forbid
````